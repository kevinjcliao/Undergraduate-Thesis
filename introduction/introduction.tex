
\chapter{Introduction}

\section{Background}
A dependently typed programming language can have functions with types that
depend on a value. A function, at its core, is a map from a domain to a
co-domain. In other words, we expect there to be a certain set of elements in
the universe for which our function can give us a corresponding output. A way to
remove certain bugs in programs is to ensure that a function in a program is
indeed mapping from the correct set of potential inputs to the set of potential
outputs. 

One can consider static type systems as a way to narrow down the set of
potential inputs to the set of possible outputs. For example, a function that
takes in a string and outputs an integer gives certain compile-time guarantees
to its programmer. If compilation succeeds, the domain of this function will be
strictly limited to an element in the set of all possible strings in the
universe and the output will be limited to an element of the set of all possible
integers. 

However, consider, for example, a function that appends an item to a list. Under
a regular type system, we would say that this function takes in a list of
elements of type a, an element of type a, and returns elements of type a. A
Haskell type signature for this function would look like this: 

\texttt{append :: [a] -> a -> [a]}. 


Let's imagine that we have a list data type signature that contains information
not only about the type of the elements that the list contains, but also about
the length of the list. That is to say, the type signature of a vect (list with
length-in-type) can be expressed as Figure~\ref{vect}.

\begin{figure}
    \caption{Using a Vect data type.}
    \label{vect}
    \begin{lstlisting}
        Vect :: Int -> Type -> Type 
        -- A length-indexed vector has an integer denoting length, 
        -- and the type of its elements. 
        [1,2,3] :: Vect 3 Int
    \end{lstlisting}
\end{figure} 

% Replicate. 

Now that we've introduced the length of the vect type as part of its type
signature, we can write a much more strict and bug-free type signature for our
append function. Essentially, any append function would take any vect with
length $n$ and type $a$. It also takes in an element of type $a$ to append. It
outputs a list of length $n+1$ and type $a$. This type signature looks like: 

$$
\texttt{append :: Vect n a -> a -> Vect (n+1) a} 
$$

What's peculiar about this is that the co-domain of this function is not
particularly fixed. In fact, it depends on the value of its input. For example,
if a list of length 3 and type Int is inputted, the co-domain of our function is
the set of all lists with length 4 and type integer. This is an example
application of dependent types. What we've done is created a function where the
co-domain varies as the input value varies. The guarantee of type safety
provided by this type signature is substantial. 

The goal of dependent types is to write programs with extreme guarantees of
compile-time safety. We can use the types of the parameters of a function to
place tighter limits on the set that consists of its co-domain, with the
co-domain varying depending on the values of the input parameters. 

In this literature review, I will explore existing literature around practical
real-world applications of dependent types. I'll take a look at three examples
where a domain specific language can be built if a language can support full
dependent types. I'll then show how dependent types can be applied to make
systems programming and building distributed systems safer. I'll also take a
look at how a dependently typed language can implement units of measurement,
preventing a set of potentially costly and fatal human errors. The hope is to
demonstrate that dependent types, long confined to theoretical mathematics, have
tremendous promise in helping programmers build reliable and safe programs. 




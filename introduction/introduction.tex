
\chapter{Literature Review}

\section{Background}
A dependently typed programming language can have functions with types that
depend on a value. A function, at its core, is a map from a domain to a
co-domain. In other words, we expect there to be a certain set of elements in
the universe for which our function can give us a corresponding output. A way to
remove certain bugs in programs is to ensure that a function in a program is
indeed mapping from the correct set of potential inputs to the set of potential
outputs. 

One can consider static type systems as a way to narrow down the set of
potential inputs to the set of possible outputs. For example, a function that
takes in a string and outputs an integer gives certain compile-time guarantees
to its programmer. If compilation succeeds, the domain of this function will be
strictly limited to an element in the set of all possible strings in the
universe and the output will be limited to an element of the set of all possible
integers. 

However, consider, for example, a function that appends an item to a list. Under
a regular type system, we would say that this function takes in a list of
elements of type a, an element of type a, and returns elements of type a. A
Haskell type signature for this function would look like this: 

\texttt{append :: [a] -> a -> [a]}. 


Let's imagine that we have a list data type signature that contains information
not only about the type of the elements that the list contains, but also about
the length of the list. That is to say, the type signature of a vect (list with
length-in-type) can be expressed as: 

\begin{figure}
    \caption{Using a Vect data type.}
    \begin{lstlisting}
        Vect :: Int -> Type -> Type -- A list has an integer denoting length, 
        -- and the type of its elements. [1,2,3] :: Vect 3 Int
    \end{lstlisting}
\end{figure} 


Now that we've introduced the length of the vect type as part of its type
signature, we can write a much more strict and bug-free type signature for our
append function. Essentially, any append function would take any vect with
length $n$ and type $a$. It also takes in an element of type $a$ to append. It
outputs a list of length $n+1$ and type $a$. This type signature looks like: 

$$
\texttt{append :: Vect n a -> a -> Vect (n+1) a} 
$$

What's peculiar about this is that the co-domain of this function is not
particularly fixed. In fact, it depends on the value of its input. For example,
if a list of length 3 and type Int is inputted, the co-domain of our function is
the set of all lists with length 4 and type integer. This is an example
application of dependent types. What we've done is created a function where the
co-domain varies as the input value varies. The guarantee of type safety
provided by this type signature is substantial. 

The goal of dependent types is to write programs with extreme guarantees of
compile-time safety. We can use the types of the parameters of a function to
place tighter limits on the set that consists of its co-domain, with the
co-domain varying depending on the values of the input parameters. 

In this literature review, I will explore existing literature around practical
real-world applications of dependent types. I'll take a look at three examples
where a domain specific language can be built if a language can support full
dependent types. I'll then show how dependent types can be applied to make
systems programming and building distributed systems safer. I'll also take a
look at how a dependently typed language can implement units of measurement,
preventing a set of potentially costly and fatal human errors. The hope is to
demonstrate that dependent types, long confined to theoretical mathematics, have
tremendous promise in helping programmers build reliable and safe programs. 

\section{Dependent Types: A History}
Dependent types in programming languages have their roots in intuitionistic type
theory or Martin-L\"{o}f Type Theory \cite{intro_martin_lof, ml_type_theory}. This
type theory serves as a foundation for \textit{constructive mathematics}
\cite{constructive_math}. Per Martin-L\"{o}f was interested in a type theory that
could be used as a programming language, where all well-typed programs must
terminate \cite{ml_type_theory}. His type theory is based on the principles of
constructive mathematics, mainly Curry-Howard isomorphism. Curry-Howard
isomorphism is the notion that there is a direct correspondence between
mathematical proofs and type theory. In other words, a type signature is
synonymous with a mathematical proposition, and if a valid program satisfying
the constraints of such a type signature exists, then a proof proving the
corresponding mathematical proposition \cite{martin_lof, ml_type_theory}. To
illustrate this, consider the examples in Figure ~\ref{ml_type_theory_examples}
\footnote{These examples were provided by Prof. Richard Eisenberg in a
discussion.}. 

\begin{figure}[h]
    \label{ml_type_theory_examples}
    \caption{Comparison between Haskell type signatures and mathematical proofs to illustrate Curry-Howard Isomorphism}
    \begin{tabular}{c|c|c|c}
        Haskell Type Signature & Math Proposition & Haskell type signature inhabited? & Proof exists? \\
        $\forall a. a \rightarrow a$ & $p \rightarrow p$ & True & True \\
        $\forall ab. (a,b) \rightarrow a$ & $ (p \wedge q) \rightarrow p$ & True & True \\
        $\forall ab. a \rightarrow b$ & $p\rightarrow q$ & False & False \\
        $\forall ab. a \rightarrow (a,b)$ & $p \rightarrow (p\wedge q)$ & False & False 
    \end{tabular}
\end{figure}

From the figure, we see the Curry-Howard isomorphism that forms the fundamentals
of Martin-L\"{o}f's type theory. We see that in all four cases, if there is a
function that inhabits the type signature, the mathematical proposition
presented is valid and if a function does not exist, the proposition is invalid. 

Mathematicians took an interest in creating a programming language based on
Curry-Howard isomorphism and Martin-L\"{o}f type theory, since Curry-Howard
isomorphism meant that a valid function that inhabits a type signature could be
equivalent to a proof. A dependently typed programming language based on
foundations in Martin-L\"{o}f Type Theory called NuPrl was first released in
1984 \cite{nuprl}. NuPrl is used as a \textit{proof assistant} that helps
mathematicians and programmers formalize proofs \cite{prl_home}. Dependently
typed proof assistants like NuPrl found a home at the intersection between
programming language enthusiasts interested in total program correctness and
constructive mathematicians interested in systems where mathematical formulisms
could be systematically encoded. Other proof assistants with support for
dependent types followed: Coq (1989) \cite{girard1989proofs}, ALF (1990)
\cite{Magnusson95theimplementation}, Cayenne (1998)
\cite{Augustsson:1998:CLD:291251.289451}, Agda (1999)
\cite{structured_type_theory}.

While there are now robust theorem provers that incorporate dependent types,
work now is primarily concerned with bringing them into mainstream programming
and software development. Idris (2011) was designed with general purpose
programming in mind \cite{tdd_book}. F* (2011) was introduced by Microsoft as a
dependently typed language specifically designed around solving problems in
secure distributed programming \cite{fstar_distributed_programming}. In addition
to the development of new programming languages with dependent type systems
built into the language by design, work exists to mainstream dependent types
into more prominent programming languages. The most active and promising
mainstreaming work is on Haskell \cite{eisenberg2016, gundry2013}. 

\section{Implementing Domain-Specific Languages with Dependent Types}

\subsection{Cryptol: A DSL for Cryptography}

Dependent type systems have potential applications in easily implementing domain
specific languages (DSLs). Cryptol, for example, is a domain-specific language
designed around cryptography (\cite{cryptol_manual}). Problems inherent in
implementing a Cryptol compiler or interpreter can be solved through dependent
types (\cite{power_of_pi}). Cryptol is a functional programming language with
advanced support for pattern matching. Since cryptography commonly requires
dealing with low-level bit manipulation, it follows that Cryptol is designed
around facilitating these operations and making them safe. A function that does
this sort of low-level manipulation is the \texttt{swab} function, which takes
in a 32-bit word and swaps the first two bytes (\cite{cryptol_manual}).: 

$$
\texttt{swab :: Word 32 -> Word 32} \\
\texttt{swab [a b c d] = [b a c d]} $$

Ideally, a word would be represented by a vector of 32-bits. We would be able to
declare a pattern match with swab that looks similar to the declaration
presented by Oury and Swiestra above. How then does the compiler understand that
this pattern match declaration means we expect the input vector to be divided
into 4 separate vectors of 8 bits? This is where dependent types serve a
practical purpose. By specifying types that split the length of the vector up
into a multiple of two scalars, we can effectively implement this clever pattern
match, allowing for powerful pattern matching required by the Cryptol language
(\cite{power_of_pi}). 

\textit{More coming in final draft of literature review}

\subsection{PBM: Generating Parsers with Data Description Languages}

\input{examples/pbm_parser}

\subsection{Safer Databases: Relational Algebras}

\input{examples/databases}

\section{Systems Programming with Dependent Types}

General purpose dependently typed programming languages such as Idris (and in
the future, Haskell), allow programmers to integrate dependent types into lower
level work than a theorem proving language would allow. This section of the
literature review will take a look at Brady's \textit{Idris: Systems Programming
Meets Full Dependent Types} \cite{idris_systems_programming}.

\section{Well-Typed Unit Measurements with Dependent Types}

\input{examples/units_of_measurement}

\section{Programming Distributed Systems}

To be included in the final literature review. A review of ``Secure Distributed
Programming with Value-Dependent Types''. \cite{fstar_distributed_programming}

\section{Programming with Algebraic Effects}

\input{examples/algebraic_effects}

\section{Proposal for Future Work}

While I'm still uncertain about the direction to proceed, I'm interested in
looking at elections and e-voting and whether or not we can provide guarantees
of correctness to vote counting software written in dependently typed languages.
I take a particular interest in the Australian Senate voting verification
process because verification of vote count is an NP-complete problem
(\cite{aus_senate}). 

If we were able to verify that vote counting software is correct at
compile-time, we would sidestep the need to run verification code that is trying
to solve an np-complete problem. Currently, the Australian government uses
proprietary code to count Australian senate ballots and has refused to release
the source code after a Freedom of Information Act request
(\cite{aus_senate_news}). If an open-sourced, verifiably correct counting
program were devised, we could greatly protect the integrity of Australian
elections. 

\section{Conclusion}
While many literature reviews begin by looking examining a problem and looking
for existing solutions, this literature review takes an opposite approach. The
broader problem we are trying to answer is one that crosses various domains and
engineering fields. To put it quite simply, \textit{programs crash}. Dependent
typed languages, long a toy for theoretical computer scientists and
constructivist mathematicians, are increasingly becoming realistic tools to
write code with necessary guarantees of correctness. In other words, dependent
types are a solution in search of a problem. 

In this literature review, I offered a brief summary as to what dependent types
are and what languages exist where dependent type functionality is available. I
then moved on to describe different applications of dependently typed
programming that exist in literature. I started by looking at Cryptol, a DSL for
cryptography, and showed how dependent types allow for implementing complex
pattern-matching that the language requires \cite{power_of_pi}. I then moved on
to discuss embedded data description languages, showing how one can describe how
data is structured and generate a parser out of such a description
\cite{power_of_pi}. I also examined the potential of dependent types to build a
typesafe database, eliminating runtime typechecking and thus reducing error and
increasing performance \cite{power_of_pi, eisenberg2016}. 

Outside of domain specific languages, I also showed the application of dependent
types to systems programming \cite{idris_systems_programming}, building
distributed systems \cite{fstar_distributed_programming} and units of
measurement \cite{gundry2013}. In this wide-ranging review, I've demonstrated
that as dependent types become brought into the mainstream, they have the
potential to empower programmers to build safe, robust programs in ways that
have not been possible before. 
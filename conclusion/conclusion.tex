
\chapter{Conclusion}

\section{Conclusions on the Literature Review of Dependent Types}

While many literature reviews begin by looking examining a problem and looking
for existing solutions, this literature review takes an opposite approach. The
broader problem we are trying to answer is one that crosses various domains and
engineering fields. To put it quite simply, \textit{programs crash}. Dependent
typed languages, long a toy for theoretical computer scientists and
constructivist mathematicians, are increasingly becoming realistic tools to
write code with necessary guarantees of correctness. In other words, dependent
types are a solution in search of a problem. 

In all of these applications, I found something incredibly interesting that I'd
like to reflect on. I don't deny that the process of understanding all of these
papers at the undergraduate-level has not been an easy undertaking. This is
important because the underlying discussion question about this literature
review has been making dependent types accessible to a practical programmer.
However, while writing out inductive proofs in Idris or building a relational
algebra are difficult tasks, the result is surprisingly easy for a programmer to
use. 
\begin{enumerate}
    \item A programmer wanting to use well-typed units of measurement can simply
    import a library of SI units without having to worry about proving lemmas
    that demonstrate two derived units are the same. 
    \item A programmer wanting to build a parser can simply describe the data
    using a provided data description language. 
    \item A programmer wanting to use a type-safe relational database simply has
    to express schemas and then write expressions in our relational algebra
    detailing the input and output schema. 
    \item A programmer looking to implement complicated pattern-matching for a
    domain-specific language like Cryptol can easily implement that complex
    pattern-matching, as well as many other complicated pattern-matching
    techniques once splitView and its associated lemmas are implemented. 
    \item A programmer who wants to use the algebraic effects DSL can just
    describe the side effects present in their function without worrying about
    the complex underlying dependently-typed machinations. 
\end{enumerate}

In other words, at the current state, I find dependent types to still be too
complicated for the average programmer to understand. What people who understand
dependent types can do however, is work on dependently typed libraries where the
building blocks of what a programmer might use are dependently typed. A
programmer who uses a dependently-typed relational algebra needn't understand
the complex underlying machinations of building such a relational algebra. They
merely need to understand that writing schemas and expressions in the relational
algebra give way to type safety. In other words, the problem of getting every
programmer to love and write programs with dependent types is certainly
non-trivial, but providing dependently-typed libraries can be easily done. You
can't make a kid love vegetables, but nothing's stopping you from slipping a
little spinach into their dinner. 

Eventually however, the libraries that we've described will still require a
programmer to deal with increasingly complex error messages. Programmers using
dependently-typed libraries will eventually need to dig down and fight with the
compiler. However, dependently-typed libraries that are easy to use provide
entry points for programmers to become familiar with the safety provided by
dependent types. In other words, as work continues on mainstreaming dependent
types, programmers and academics with a deep understanding of dependent types
who wish to see its proliferation should work on providing well-written
libraries that encourage practical programmers to give dependent types a shot.

\section{Conclusions from Writing Palpatine}

The second portion of this senior thesis, the writing of \textit{Palpatine},
taught me a great deal as well. Some of the conclusions I've written below. 

\subsection{STV is an Algorithm in Need of a Declaration Specification}

I'm incredibly concerned by the fact that there does not currently exist an
official, Australian Electoral Commision sanctioned specification of STV.
Legislation serves as something close to a \textit{formal specification}, but as
has been noted in literature, there are gaps. For example, legislation currently
has no specification for tiebreaking behaviour \cite{stv_haskell}. Currently,
\textit{Palpatine} will choose the leftmost, first occurring highest scored
candidate and elect that one. This is obviously unfair, but occurs within the
confines of a legislative system that does not account for the unlikely event of
a tie. 

Given that there is no formal AEC sanctioned specification, I had to go about
finding pseudocode based on a high-level description of counting ballots
provided on their website. Furthermore, in addition to a formal specification of
the algorithm's behaviour, I could not find a formal specification for the
algorithm's intent. What does it mean for the STV algorithm to ``succed''? Why
is it optimal to eliminate and elect candidates in the order we do? What is the
definition of an optimally accurate election result and how does STV reflect
that? These questions blur the line between Mathematics, Computer Science and
Policy, but they are important questions and deserve to be addressed and must be
addressed. 

\subsection{Totality Checkers Are Good.}

Guarantees of termination are good for the user. STV vote counting can take a
while. When running the code from Ghale, Gore and Pattinson, counting STV
ballots for an election of the Australian Capital Territory took 3 days
\cite{stv_haskell}. The point is, counting STV elections can be difficult. More
than once, I wondered if the program was not going to terminate. Idris provides
a built-in totality checker, which as specified above, means that there are
compile-time guarantees of termination. This means proofs of termination are not
required. 

While significant, non-trivial barriers exist to implementing a totality checker
in Haskell, the experience I had with implementing an STV counter in Idris leads
me to believe that Haskell would benefit significantly from such a totality
checker. As such, I encourage and add my voice to encourage the people who are
working towards this noble goal. 

\subsection{Better Programming Languages Enable Safer Code.}

The constraints that type systems create force programmers to write better code.
For example, in the interest of satisfying totality, as described above, there
were many points during the writing of \textit{Palpatine} where I was forced to
employ usage of Monads to encapsulate side effects, or the possibility of the
lack of a return value. By forcing me towards complete case coverage, and by
writing tighter type constraints, I became a better programmer. Over time, I
embraced the concept of \textit{Type Driven Development} and would write out my
types in advance, filling the code in with typed holes and then progressively
expanding out until I had code that satisfied my type. While in the beginning, I
found this an exercise in frustration, over time I found it to be a powerful and
almost joyful paradigm to work in. 

\subsection{Verification is Hard}

I started this senior thesis with the intent of fully `verifying' the STV vote
counting algorithm. This senior thesis has been a process of humbling myself and
of realizing that the problems that I'm trying to solve are incredibly
difficult. As I learned what \textit{verification} truly was, I realized that I
could not find a formal specification for STV that would be conducive to the
process of \textit{verification}. Even after I found such a specification for
the counting of ballots, I found that verification of everything I expected
proved to be more difficult than I thought. In the end, I have produced a vote
counter that merely verifies the cardinality of two data structures. It does not
verify that the outcome is correct, nor does it verify in any way that we have
even elected the correct number of candidates. While from one perspective, this
could be seen as frustrating, I actually found it to be ultimately rewarding. I
gained even more respect for the noble goal of verification and a deeper
understanding of what it means for code to be correct. 
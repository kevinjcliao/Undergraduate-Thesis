
\chapter{Conclusion}

\section{Proposal for Future Work}

While I'm still uncertain about the direction to proceed, I'm interested in
looking at elections and e-voting and whether or not we can provide guarantees
of correctness to vote counting software written in dependently typed languages.
I take a particular interest in the Australian Senate voting verification
process because vote count is an NP-complete problem \cite{aus_senate}. 

Currently, the Australian government uses proprietary code to count Australian
senate ballots and has refused to release the source code after a Freedom of
Information Act request \cite{aus_senate_news}. If an open-sourced, verifiably
correct counting program were devised, we could greatly protect the integrity of
Australian elections. I think dependent types would lend themselves well to an
application in this context. First of all, one would have to parse large amounts
of data, which we know from one of our examples, can be done with an embedded
data description language. We will also have to count votes and redistribute
voting preferences from candidate to candidate. Such operations could be
complex, and enforcing tight constraints at the type level could mean that a
good-faith programmer or someone browsing the open-source code can know at a
quick glance that the operations are implemented correctly. 

All in all, counting votes in the Australian senate is a complicated operation
with a lot of moving parts, and I believe that the examples that we've looked at
over the course of this literature review have shown to me that there is a
certain degree of promise in implementing a dependently-typed Australian senate
vote counter. 

\section{Conclusion}
While many literature reviews begin by looking examining a problem and looking
for existing solutions, this literature review takes an opposite approach. The
broader problem we are trying to answer is one that crosses various domains and
engineering fields. To put it quite simply, \textit{programs crash}. Dependent
typed languages, long a toy for theoretical computer scientists and
constructivist mathematicians, are increasingly becoming realistic tools to
write code with necessary guarantees of correctness. In other words, dependent
types are a solution in search of a problem. 

In all of these applications, I found something incredibly interesting that I'd
like to reflect on. I don't deny that the process of understanding all of these
papers at the undergraduate-level has not been an easy undertaking. This is
important because the underlying discussion question about this literature
review has been making dependent types accessible to a practical programmer.
However, while writing out inductive proofs in Idris or building a relational
algebra are difficult tasks, the result is surprisingly easy for a programmer to
use. 
\begin{enumerate}
    \item A programmer wanting to use well-typed units of measurement can simply
    import a library of SI units without having to worry about proving lemmas
    that demonstrate two derived units are the same. 
    \item A programmer wanting to build a parser can simply describe the data
    using a provided data description language. 
    \item A programmer wanting to use a type-safe relational database simply has
    to express schemas and then write expressions in our relational algebra
    detailing the input and output schema. 
    \item A programmer looking to implement complicated pattern-matching for a
    domain-specific language like Cryptol can easily implement that complex
    pattern-matching, as well as many other complicated pattern-matching
    techniques once splitView and its associated lemmas are implemented. 
    \item A programmer who wants to use the algebraic effects DSL can just
    describe the side effects present in their function without worrying about
    the complex underlying dependently-typed machinations. 
\end{enumerate}

In other words, at the current state, I find dependent types to still be too
complicated for the average programmer to understand. What people who understand
dependent types can do however, is work on dependently typed libraries where the
building blocks of what a programmer might use are dependently typed. A
programmer who uses a dependently-typed relational algebra needn't understand
the complex underlying machinations of building such a relational algebra. They
merely need to understand that writing schemas and expressions in the relational
algebra give way to type safety. In other words, the problem of getting every
programmer to love and write programs with dependent types is certainly
non-trivial, but providing dependently-typed libraries can be easily done. You
can't make a kid love vegetables, but nothing's stopping you from slipping a
little spinach into their dinner. 

Eventually however, the libraries that we've described will still require a
programmer to deal with increasingly complex error messages. Programmers using
dependently-typed libraries will eventually need to dig down and fight with the
compiler. However, dependently-typed libraries that are easy to use provide
entry points for programmers to become familiar with the safety provided by
dependent types. In other words, as work continues on mainstreaming dependent
types, programmers and academics with a deep understanding of dependent types
who wish to see its proliferation should work on providing well-written
libraries that encourage practical programmers to give dependent types a shot.
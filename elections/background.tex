\chapter{Relevant Background on the Single Transferrable Vote}

Having provided a grounding in dependently-typed programming, I now move to the
voting system that I take an interest in. I take an interest in the Single
Transferable Vote (STV) system that is used to count voter preferences in many
developed democracies. STV is used in Ireland, Australia, New Zealand, and lower
level elections across the United Kingdom and the United States. Many variants
of the system exist and I concern myself with the method of STV currently used
to count votes in the Australian Senate. 

\section{How STV works}

At a high level, STV works by first calculating the `score' of each candidate
and what they've received, knows as the \textit{Droop Quota}. If a candidate has
a total tallied vote value of higher than the Droop Quota, the candidate is
considered elected. We start by exhaustively counting the first preference on
everyone's ballot. When we finish counting these preferences, we see if any
candidate has met the Droop Quota. If such a candidate has met the Droop Quota,
we calculate their surplus (the surplus number of votes they received over the
Droop Quota). We then redistribute the ballots that voted for this winning
candidate by removing the ballots' first preference and lowering its value. If
after such a redistribution has taken place, another candidate reaches the Droop
Quota, we recount their preferences and so on. This process continues until no
count of next preferences will bring another candidate over the Droop Quota. 

When we have counted each ballot and redistributed accordingly and no candidates
will be brought over the line through a redistribution, we now eliminate the
candidate with the lowest `score' and we redistribute ballots that have voted
for that candidate to their next preferences. This continues until a candidate
hits the droop quota, after which we reallocate their surplus again. 

There are two termination conditions for this algorithm. The first is that all
seats are filled and there are leftover candidates. In such a case, we just
accept that the election is complete and discard the leftover candidates. The
second is that there are the same number or less number of leftover candidates
than there are seats available. In that case, we elect the leftover candidates
and close the election. Pseudocode for this algorithm is given below. This
pseudocode is modified from pseudocode provided by Sellstr\"om and T\~onisson
\cite{stv_pseudocode}. 

\begin{algorithm}
    \SetKwFunction{transferDown}{transferDown}
    \SetKwProg{Fn}{Function}{}{}
    \Fn{\transferDown{candidate}}{
        votes = $cand_{score}$\\
        excess = votes - droopQuota\\
        transferValue = excess/votes\\
        \For{ballot in ballots}{
            \If{ballot first preference is for candidate}{
                $ballot_{value}$ = transferValue
            }
            removeCandFromBallot
        }
    }
    \SetKwFunction{transferUp}{transferUp}
    \SetKwProg{Fn}{Function}{}{}
    \Fn{\transferUp{candidate}}{
        \For{ballot in ballots}{
            remove candidate from ballot
        }
    }
    \SetKwFunction{stv}{stv}
    \SetKwProg{Fn}{Function}{}{}
    \Fn{\stv{ballots, seats, candidates}}{
        let $dq$ = droopQuota\\
        let $vc$ denote the total vote score of each candidate where $vc_i$ is
        the score for candidate $i$\\
        let elected = empty list \\
        // Now we begin the first count. \\
        \For{each ballot b in ballots}{
            let $i$ = first preference of b\\
            $vc_i$ = $vc_i$ + 1\\
        }
        \While{ len(elected) < seats}{
            countNextBallots\\
            leader = getMaxCandScore(vc)\\
            \eIf{leader has higher score than droop Quota}{
                elected.append(leader)\\
                candidates.remove(leader)\\
                transferDown(leader)\\
            }{
                loser = getMinCandScore\\
                candidates.remove(loser)\\
                transferUp(loser)
            }
        }
        \Return{elected}
    }
\end{algorithm}


\section{A sample STV election}
\textit{This is an application of a description of the Australian Senate STV
Counting Process as described by the Australian Electoral Commision. The AEC
writeup is available
\href{https://www.aec.gov.au/Voting/counting/senate_count.htm}{here}}

In order to demonstrate how the STV system works, it would help to run a sample
election, provided below. This sample election data is not original and obtained
from prior literature for an STV vote counter in Haskell and Coq
\cite{stv_haskell}. Suppose we have three candidates, $[A, B, C]$, running for
two available seats. Now suppose that we have 5 voters who each have sent in
preferences to be counted. The preferences are shown in
Figure~\ref{sample_election}. Each voter's preferences are referenced by a list
where the leftmost element represents the most preferred candidate and the
rightmost candidate presents the voter's least preferred. There is no obligation
to number all candidates. 


\begin{figure}[ht!!!!!!!!]
    \caption{Ballots for a sample election to be run. }
    \label{sample_election}
    \begin{lstlisting}
        [A,C]
        [A,B,C]
        [A,C,B]
        [B,A]
        [C,B,A]
    \end{lstlisting}
\end{figure}

The first thing to calculate is the \textit{Droop Quota}. This represents the
voting `score' a candidate must have before they are elected. The Droop Quota is
calculated in the Australian Senate by a formula shown below. 

$$
S = floor(\frac{b}{n + 1}) + 1
$$

In this formula, $b$ refers to the number of ballots, $n$ refers to the number
of seats available, and the \textit{floor} operation refers to rounding the
result down. The Droop Quota of our sample election is, according to this formula, 

$$
S = floor(\frac{5}{2 + 1}) + 1 = floor(\frac{5}{3}) + 1 = 1 + 1 = 2
$$

Now, we assign a \textit{weight} to each ballot. Our ballots are now: 

\begin{figure}[ht!!!!!!!!]
    \caption{Ballots with initial score.}
    \label{sample_election0}
    \begin{lstlisting}
        ([A,C], 1)
        ([A,B,C], 1)
        ([A,C,B], 1)
        ([B,A], 1)
        ([C,B,A], 1)
    \end{lstlisting}
\end{figure}

We now start by counting everyone's first preferences. $A$ receives 3 ballots
each with the weight of 1.0. Thus, $A$ has reached the Droop Quota and $A$ is
elected. No one else has hit the Droop Quota yet. Now, we transfer the surplus.
We remove the ``head'' from all the ballots that preferenced A and we transfer
the surplus votes. The new value of the votes is calculated as follows: 

$$
v = s/n
$$

where $v$ is the surplus transfer value, $s$ is the surplus ballots and $n$ is
the total number of ballots that preferenced the candidate first. By applying
this formula, the Droop Quota is 2, there are 3 votes for $A$ and so there is a
surplus of 1. $B, C$ each received one vote. This means the surplus is expressed
by $\frac{1}{3}$. By removing all instances of A from the ballots, setting
ballots that preferenced A first to the transfer value, and removing all the
heads of the ballots.

\begin{figure}[ht!!!!!!!!]
    \caption{Ballots with initial score.}
    \label{sample_election1}
    \begin{lstlisting}
        ([C], 1/3)
        ([B,C], 1/3)
        ([C,B], 1/3)
        ([], 1)
        ([B], 1)
        
        elected: [A]
        
        scores: 
        (B, 1)
        (C, 1)
    \end{lstlisting}
\end{figure}

Now, we count again the first preferences of each ballot. This results in the
following ballots: 

\begin{figure}[ht!!!!!!!!]
    \caption{Ballots after second count}
    \label{sample_election2}
    \begin{lstlisting}
        ([], 1/3)
        ([C], 1/3)
        ([B], 1/3)
        ([], 1)
        ([], 1)
        
        elected: [A]
        
        scores: 
        (B, 7/3)
        (C, 5/3)
    \end{lstlisting}
\end{figure}

Now, we see that B has passed the droop quota and is elected. With no seats
left, C is eliminated. \footnote{This is different from the result in Ghale et.
al. because they use a different droop quota formula.}

\input{elections/assumptions}